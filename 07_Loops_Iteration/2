# 08 反復処理

## 反復処理

- [ループ文](#ループ文)
- [演算子と優先順位](#演算子と優先順位)
- [ループ文とブロックスコープ](#ループ文とブロックスコープ)
- [配列とループ文](#配列とループ文)
- [for...in と列挙可能性](#forin-と列挙可能性)
- [for...of と反復可能性](#forof-と反復可能性)
- [Map と Set](#map-と-set)
- [イテレータ](#イテレータ)

### ループ文

`for`文でループ処理を作成する。

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```

`while`文でループ処理を記述する。

```js
let i = 0;
while (i < 10) {
  console.log(i);
  i++;
}
```

<br>

### 演算子と優先順位

値（オペランド）を元に処理を行い、**結果を返す**記号のことを**演算子**という。

```js
a = 1 + 2
↓
a = 3
```

- [演算子の優先順位](#演算子の優先順位)
- [インクリメント演算子・デクリメント演算子](#インクリメント演算子・デクリメント演算子)

#### 演算子の優先順位

一つの式の中に複数の演算子が存在する場合は、演算子の優先順位に基づいて演算が実行されることになっている（[MDN：演算子の優先順位](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)）

先ほどの式だと、`+`の方が`=`よりも優先順位が高いため、右辺から計算が行われる。

<br>

#### インクリメント演算子・デクリメント演算子

演算子の中でもインクリメント演算子とデクリメント演算子は、演算子の記号をオペランドの前に置くか、後に置くかで動きが変わるので注意が必要。

```js
let a = 0;
console.log(++a); // 1
console.log(a); // 1

a = 0;
console.log(a++); // 0
console.log(a); // 1
```

<br>

### ループ文とブロックスコープ

ループ文では、1 ループごとにブロックスコープが切り替わる。

```js
for (let i = 0; i < 5; i++) {
  const j = i * 2;
  setTimeout(() => console.log(j), 1000); // 0, 2, 4, 6, 8
}
```

ブロック内で`var`で宣言すると、グローバルスコープで宣言したのと同じになる。

```js
for (let k = 0; k < 5; k++) {
  var l = k * 2;
  setTimeout(() => console.log(l), 1000); // 8
}
```

<br>

### 配列とループ文

`for`文を使って配列の中身を出力させる。

```js
const arr = [1, 2, 3, 4, 5];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 1 2 3 4 5
}
```

`while`文を使って同じ処理を記述する。

配列の要素がないインデックスまでループさせる。

```js
let v,
  i = 0;
while ((v = arr[i++])) {
  console.log(v); // 1 2 3 4 5
}
```

<br>

### for...in と列挙可能性

列挙可能性とは、オブジェクトの各プロパティが持っているディスクリプタの中に含まれる`enumerable`の設定値のことを指す。

また、`enumerable`が`true`に設定されているプロパティを、**列挙可能プロパティ**と呼ぶ。

- [for...in](#forin)
- [Symbol と for...in](#symbol-と-forin)

#### for...in

**列挙可能プロパティ**に対して順不同で反復処理を実行する。

```js
const obj = {
  prop1: "value1",
  prop2: "value2",
  prop3: "value3",
};

for (let key in obj) {
  console.log(key, obj[key]); // prop1 value1, prop2 value2, prop3 value3
}
```

列挙対象から外したい場合は、`defineProperty`で設定する。

```js
Object.prototype.method = function () {};
Object.defineProperty(Object.prototype, "method", {
  enumerable: false,
});

const d = getOwnPropertyDescriptor(Object.prototype, "method");
console.log(d); // { writable: true, enumerable: false, configurable: true, value f }
```

基本的にオブジェクトのビルトインメソッドは`enumerable`の値がデフォルトで`false`になっているので、列挙対象になっていない。

プロトタイプチェーン内も列挙対象となる → `Object.hasOwnProperty`を使用する。オブジェクトが自身で所有しているプロパティのみ列挙する。

```js
for (let key in obj) {
  obj.hasOwnProperty(key);
  console.log(key, obj[key]); // prop1 value1, prop2 value2, prop3 value3
}
```

<br>

#### Symbol と for...in

Symbol で定義したプロパティは`for...in`で列挙対象にはならない。

```js
const s = Symbol();
const obj = {
  prop1: "value1",
  prop2: "value2",
  prop3: "value3",
  [s]: "value4",
};

const e = getOwnPropertyDescriptor(obj, s);
console.log(e); // { writable: true, enumerable: true, configurable: true, value: 'value4' }
```

<br>

### for...of と反復可能性

**イテレーター**を持つオブジェクトの反復操作を行う。

イテレーターとは、反復処理を行う際に使用するオブジェクトで、次のようなものがある。

- String
- Array
- Map
- Set
- arguments
- etc...

これらイテレーターを持つオブジェクトのことを、**反復可能オブジェクト**と呼ぶ。

```js
const arr = ["a", "b", "c"];

// インデックスの3は値がないので、undefinedになる
arr[4] = "e";

// enumerableの値は関係ない
Object.defineProperty(arr, 0, {
  enumerable: false,
});

for (let v of arr) {
  console.log(v); // a b c undefined e
}
```

<br>

### Map と Set

データを管理するための入れ物で、**コレクション**とも言う。

- [Object と Map の違い](#object-と-mapの違い)
- [Array と Set の違い](#array-と-setの違い)

#### Object と Map の違い

| 項目       | Object | Map      |
| ---------- | ------ | -------- |
| キー       | 文字列 | 制約なし |
| `for...in` | ⭕️    | ❌       |
| `for...of` | ❌     | ⭕️      |

```js
// mapを作成する
const map = new Map();
const key1 = {};

// キーとバリューをセットする
map.set(key1, "value1");
// キーを指定してバリューを取り出す
console.log(map.get(key1)); // value1

const key2 = function () {};
map.set(key2, "value2");
console.log(map.get(key2)); // value2

let key3;
// キーのセット時に初期値を代入しても問題ない
map.set((key3 = 0), "value3");
console.log(map.get(key3)); // value3
// キーがプリミティブ型の場合は、直接キー値を指定してもバリューを取得できる
console.log(map.get(0)); // value3

// mapから値を削除する
map.delete(key3);
console.log(map.get(key3)); // undefined

// 配列でキーバリューを取得する
for (const m of map) {
  console.log(m); // [{}, 'value1'] [f, 'value2']
}

// 分割代入でキーバリューを取得する
for (const [k, v] of map) {
  console.log(k, v); // {} 'value1', f(){} 'value2'
}
```

<br>

#### Array と Set の違い

| 項目     | Array | Set |
| -------- | ----- | --- |
| 重複値   | ⭕️   | ❌  |
| for...in | ⭕️   | ❌  |
| for...of | ⭕️   | ⭕️ |

`Set`は配列のように添え字で値の取得ができないので、その場合は配列を使用する。

```js
// Setをインスタンス化する
const s = new Set();
// Setの場合は値が重複しても1つしか扱われない
s.add(key1);
s.add(key1);
s.add(key2);
s.add(key3);
// 値を削除する
s.delete(key3);
// 値が含まれているかどうか確認する
console.log(s.has(key2)); // true
console.log(s.has(key3)); // false

// Setを配列に変換する
const arr = Array.from(s);
// スプレッド構文でも配列に変換できる
const arr2 = [...s];

for (let k of s) {
  console.log(k); // {}, f() {}
}
```

<br>

### イテレータ

反復操作を行う際に使用するオブジェクト。

イテレータの定義を理解するにあたって、イテレータで使用されている**IteratorResult オブジェクト**について理解する必要がある。IteratorResult オブジェクトは 2 つのプロパティは 2 つのプロパティ`done`と`value`を含んでいるオブジェクト。

| プロパティ | 値                | 反復処理における意味 |
| ---------- | ----------------- | -------------------- |
| `done`     | true または false | 反復が完了したか     |
| `value`    | 任意              | 反復処理に渡される値 |

イテレータは`next`メソッドを持っているオブジェクトとして定義され、`next`メソッドは**IteratorResult オブジェクトを戻り値とする関数**でなければならない。

```js
function genIterator(max) {
  let i = 0;

  // イテレーター
  return {
    next: function () {
      if (i >= max) {
        return {
          done: true,
        };
      } else {
        // IteretorResultオブジェクト
        return {
          done: false,
          value: i++,
        };
      }
    },
  };
}

const it = genIterator(10);
console.log(it.next()); // { done: false, value: 0 }
console.log(it.next()); // { done: false, value: 1 }
console.log(it.next()); // { done: false, value: 2 }
console.log(it.next()); // { done: false, value: 3 }
console.log(it.next()); // { done: false, value: 4 }
```

`while`文でイテレータを用いた反復処理を実行する。

```js
let a = it.next();
while (!a.done) {
  console.log(a.value); // 0 1 2 3 4 5 6 7 8 9
  a = it.next();
}
```

Symbol のイテレータに追加して反復可能オブジェクトとして使用する。

ただし実引数を取ることができないので、仮引数には初期値をセットしておく必要があり、ないと無限ループになってしまう。

```js
const obj = {
  [Symbol.iterator]: genIterator,
};

for (const i of obj) {
  console.log(i); // 0 1 2 3 4 5 6 7 8 9
}
```

仮引数の値を変更したい場合は`bind`メソッドを使用する。

```js
const obj = {
    [Symbol.iterator]
  }
```

- [07 関数とオブジェクト 2](../06_Functions_Objects_2/07.md)
- [09 非同期処理](../08_Asynchronous/09.md)
- [Top へ戻る](../README.md)
