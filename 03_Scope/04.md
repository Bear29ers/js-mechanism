# 04 スコープ

## スコープ

- [スコープとは](#スコープとは)
- [グローバルスコープとスクリプトスコープ](#グローバルスコープとスクリプトスコープ)
- [関数スコープとブロックスコープ](#関数スコープとブロックスコープ)
- [レキシカルスコープ](#レキシカルスコープ)
- [スコープチェーン](#スコープチェーン)
- [クロージャー](#クロージャー)
- [即時関数](#即時関数)

### スコープとは

実行中のコードから値と式が参照できる範囲を指す。

JavaScript の場合は一行ずつ実行されていくので、その実行する行から見える値の式をスコープという。

JavaScript には 5 種類のスコープが存在する。

- グローバルスコープ
- スクリプトスコープ
- 関数スコープ
- ブロックスコープ
- モジュールスコープ

<br>

### グローバルスコープとスクリプトスコープ

グローバルコンテキスト（関数内ではない）で宣言した変数や関数のスコープは以下のようになる。

| 命令       | スコープ           |
| ---------- | ------------------ |
| `let`      | スクリプトスコープ |
| `const`    | スクリプトスコープ |
| `var`      | グローバルスコープ |
| `function` | グローバルスコープ |

JavaScript においては、Window オブジェクトそれ自体がグローバルスコープになっている。

一般的には使い勝手が変わらないので、スクリプトスコープもグローバルスコープと呼ばれる。ただし、特殊な例では実行結果が変わる可能性があるため、2 つが異なるスコープであることは留めておく。

```js
let a = 0;
let b = 0;
function c() {}

console.log(window.b);

// Windowオブジェクトはグローバルスコープになっている
window.d = 1;
// こちらの定義が優先される（スコープチェーン）
let d = 2;
console.log(d); // 2
```

- [グローバルスコープ](#グローバルスコープ)
- [スクリプトスコープ](#スクリプトスコープ)

#### グローバルスコープ

グローバルスコープとは、厳密には Window オブジェクトのことを指す。コードのどこからでもアクセスすることができる。

グローバルコンテキスト（関数内ではない）において、`var`命令で宣言された変数や、`function`命令で宣言された関数はグローバルスコープ（Window オブジェクト＿に属することになる。

<br>

#### スクリプトスコープ

スクリプトスコープとは、グローバルコンテキストにおいて、`let`命令や`const`命令で宣言された変数・定数が所属するスコープのこと。

<br>

### 関数スコープとブロックスコープ

- [関数スコープ](#関数スコープ)
- [ブロックスコープ](#ブロックスコープ)

#### 関数スコープ

関数スコープとは、`function a() {...}`の波括弧`{}`で囲まれた部分が形成する範囲（スコープ）のこと。

関数内スコープ内で定義した変数は、その関数スコープ外からアクセスしようとするとエラーになる。

```js
function a() {
  let b = 0;
  // アクセスできる
  console.log(b);
}

// 関数スコープ外なのでエラー
console.log(b);
a();
```

<br>

#### ブロックスコープ

JavaScript ではブロックとは波括弧`{}`のことを指し、ブロックスコープとは波括弧`{}`で囲まれた部分が形成する範囲（スコープ）のこを指す。関数も波括弧を使用しているが、`function`宣言がその前に記述されているので、こちらは別物として扱う。

ブロック内では変数は`let`もしくは`const`で宣言しないと、スコープが無視される。

一般的には if 文や for 文と一緒にブロックスコープは生成される。

```js
{
  // ブロックスコープではletもしくはconstで宣言
  const c = 1;
  console.log(c);
  var d = 2;

  function e() {
    console.log("e is called");
  }

  // constで変数宣言を行っているため、ブロックスコープ外からはアクセスできない
  const f = function () {
    console.log("f is called");
  };
}

// ブロックスコープ外なのでエラー
console.log(c);

// var宣言はブロックスコープ外からもアクセスできる
console.log(d);

// 関数宣言もブロックスコープ外からもアクセスできる
e();
f();
```

<br>

### レキシカルスコープ

レキシカル（Lexical） - 語彙の、辞書（編集）の、辞書的な...

プログラミングにおいては、プログラムの文脈でソースコードの**どこ**に**何を**書いているかという意味。

レキシカルスコープとは、コードを書く**場所によって参照できる変数**が変わるスコープのこと。コードを記述した時点で決定するため、「**静的スコープ**」とも呼ばれる。**どのようにしてスコープを決定するか**の仕様の意味合いもある。
外部スコープを参照できるという仕組みのためコードを配置する位置によって参照できる変数（参照できるスコープ）が変化する。

```js
let a = 2;
function fn1() {
  let b = 1;
  function fn2() {
    let c = 3;
    // bはアクセスできる
    console.log(b);
  }
  fn2();
}
fn1();

/*
グローバルスコープ - a, fn1
関数スコープ（fn1） - b, fn2
関数スコープ（fn2） - c
*/
```

<br>

### スコープチェーン

スコープチェーンとは、スコープが複数階層で連なっている状態のことを指す。あるスコープが他のスコープを含んでいる状態。

```js
let a = 2; // let a = 1;もコメントアウトするとこちらのaが参照される

function fn1() {
  let a = 1; // let a = 3;をコメントアウトするとこちらのaが参照される
  function fn2() {
    let a = 3;
    // a = 3が出力される
    console.log(a);
  }
  fn2();
}
fn1();
```

スコープが複数階層になっている場合は、一番内側となる現在のスコープから変数を探し、なければ一つずつ外側のスコープへと変数を探しにいく。

グローバルスコープ（Window オブジェクト）はスクリプトスコープよりも外側のスコープのため、以下は`a = 2`が参照される。

```js
let a = 2;
window.a = 4;
function fn1() {
  console.log(a); // a = 2
}
fn1();
```

<br>

### クロージャー

クロージャーとはレキシカルスコープの変数を関数が使用している状態。

クロージャーを使用することによって、次のような特殊な機能を持った関数を実装することができる。

- [プライベートな変数を持った関数](#プライベートな変数を持った関数)
- [動的な関数の生成](#動的な関数の生成)

#### プライベートな変数を持った関数

グローバルスコープで定義した変数は、コードのどこからでも変更できてしまうため、誤って変更してしまったり、意図しない挙動になる可能性がある。

```js
// グローバルコンテキストで定義する
let num = 0;
increment(); // 1
increment(); // 2
increment(); // 3

function increment() {
  // 毎回numを0で定義するため、ここで定義すると毎回結果が同じになる
  // let num = 0;
  num = num + 1;
  console.log(num);
}

// numはどこからでも変更できてしまう
num = 0;
// increment()を呼んだ際に値が重複する
increment();
```

これを解決するために、クロージャーを用いて関数の内部に外部からアクセスできない**プライベート変数**を定義する。
クロージャーの性質を用いて、関数の内部でのみ使用でき、かつ値を保持し続ける変数を定義することができる。

```js
function incrementFactory() {
  // numの初期化はincrementFactoryが実行された時のみ
  let num = 0;

  // 関数スコープ内なので、numを参照可能
  function increment() {
    num = num + 1;
    console.log(num);
  }

  // JavaScriptでは関数自体も戻り値として使える
  return increment;
}

// 関数スコープ外からのアクセスはエラー
// console.log(num);

// 戻り値は関数で、numが初期化される
const increment = incrementFactory();

increment(); // 1
increment(); // 2
increment(); // 3
```

<br>

#### 動的な関数の生成

ここでいう、「動的な関数の生成」とは、プログラムのコードの中でそのときの必要性に応じた設定の関数を生成できることを指す。

レキシカルスコープの引数を参照したクロージャー関数を使うことで、外側の関数が実行された後も引数の値は保持されることになる。引数に与える値を変更することで、必要な関数を自由に生成することができる。（= クロージャーで動的に関数を生成する）

```js
function addNumberFactory(num) {
  function addNumber(value) {
    // レキシカルスコープの引数を参照する
    return num + value;
  }
  return addNumber;
}

// numは保持される
const add5 = addNumberFactory(5);
// 別の関数として定義される
const add10 = addNumberFactory(10);
const result = add5(10);
const result5 = add10(10);

console.log(result); // 15
console.log(result2); // 20
```

<br>

### 即時関数

即時関数とは、関数定義と同時に一度だけ実行される関数のこと。IIFE（_Immedeiately Invoked Function Expression_）という略称で呼ばれる。

実行結果が戻り値として呼び出し元に返される。

```js
let result = function (仮引数) {
  ...
  return 戻り値;
})(実引数);

// グループ化と関数呼び出し
(a)();

// グループ化演算子
let b = (1 + 2) * 3;
console.log(b);
```

ある処理の中でしか使用できない変数・関数と、その処理でも使用できる変数・関数を区別したいときに即時関数を使って区別することができる。即時関数内で定義した変数や関数を、即時関数のスコープ内で使用したい場合は戻り値をオブジェクトリテラルにして返す。

```js
// 戻り値は呼び出し元に返る
let c = (function (d) {
  console.log("called " + d);

  // 即時関数の実行時に一度だけ初期化される
  let privateVal = 0;
  let publicVal = 10;

  function privateFn() {
    console.log("privateFn is called");
  }

  function publicFn() {
    // レキシカルスコープで参照する
    console.log("publicFn is called: " + privateVal++);
  }

  return {
    publicVal,
    publicFn,
  };
})(10);

// 関数スコープの外側から呼び出すことができる
c.publicFn(); // called 10, publicFn is called: 0
c.publicFn(); // publicFn is called: 1
c.publicFn(); // publicFn is called: 2
console.log(c.publicVal); // 10
console.log(c); // {publicVal: 10, publicFn; f}
```

<br>

- [03 JavaScript とは](../02_Execute_Environment/03.md)
- [05 変数](../04_Variables/05.md)
- [Top へ戻る](../README.md)
