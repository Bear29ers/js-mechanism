# 09 非同期処理

## 非同期処理

- [ブラウザと JavaScript](#ブラウザと-javascript)
- [同期処理と非同期処理](#同期処理と非同期処理)
- [タスクキューとコールスタック](#タスクキューとコールスタック)
- [非同期処理のチェーン](#非同期処理のチェーン)
- [Promise チェーン](#promise-チェーン)
- [Promise と並列処理](#promise-と並列処理)
- [Macrotasks と Microtasks Part.1](#macrotasks-と-microtasks-part1)

### ブラウザと JavaScript

- [ブラウザとスレッド](#ブラウザとスレッド)
- [メインスレッド](#メインスレッド)

#### ブラウザとスレッド

スレッドとは、**連続して実行される一本の処理の流れ**を意味する。

まず「処理 A」を実行し、「処理 A」が終了したら「処理 B」の実行を開始し、「処理 B」が終了したら「処理 C」を開始する...というように、順番に実行する処理の流れをスレッドと言う。

JavaScript を実行するブラウザには以下のスレッドが存在する。

- **Main Thread**
- Service Worker
- Web Worker

主に JavaScript が実行されるのはメインスレッドになる。

<br>

#### メインスレッド

ブラウザのメインスレッドでは、「**JavaScript の実行**」と「**レンダリング（画面描画処理）**」の 2 つの処理が行われる。

JavaScript の実行が先に行われ、その結果、画面への変更がある場合にはレンダリングが行われる。

<br>

#### FPS（Frames Per Second）

FPS は**1 秒間あたりの画面（フレーム）更新頻度の単位**であり、「60fps」は 1 秒間に 60 回画面を更新する。 = `16.7ms`に 1 回画面が更新されることを意味する。

60fps であれば、人の目にはスムーズに変化しているように見える。

<br>

### 同期処理と非同期処理

- [同期処理](#同期処理)
- [非同期処理](#非同期処理)

#### 同期処理

- 同期処理では**メインスレッド**でコードが順番に実行される。
- 同期処理では一つの処理が完了するまで次の処理には進まない。

```js
function sleep(ms) {
  const startTime = new Date();
  while (new Date() - startTime < ms);
  console.log("sleep done");
}

const btn = document.querySelector("button");
btn.addEventListener("click", function () {
  console.log("button clicked");
});

// メインスレッドを5秒間使用する => その間クリックイベントが使えない
sleep(5000);

// 最初の2秒間メインスレッドを解放する
setTimeout(function () {
  sleep(3000);
}, 2000);
```

<br>

#### 非同期処理

- 非同期処理は一時的にメインスレッドから処理が**切り離される**。
- 非同期処理では順番に実行しない処理や完了しなくても次の処理に進んでしまうような処理のことを指す。

代表的なものとしては以下が存在する。

- 非同期 API
  - `setTimeout`
  - `Promise`
  - `queueMicrotask`
- UI イベント
  - クリック
- NW イベント
- I/O イベント

<br>

### タスクキュートコールスタック

- [コールスタック](#コールスタック)
- [タスクキュー](#タスクキュー)
- [イベントループ](#イベントループ)

#### コールスタック

コールスタックは実行中のコードが辿ってきたコンテキストを積み重ねたもので、一番上に積まれているコンテキストが現在実行中のコンテキストを表す。

<br>

#### タスクキュー

実行待ちの非同期処理の行列のことをタスクキューといい、非同期処理の**実行順**を管理しているタスクキューに入った処理（タスク）が順番に非同期で実行される。

<p align="center">
  <img width="700px" alt="TaskQueue" src="https://user-images.githubusercontent.com/39920490/230836059-0be688cf-ef59-4c5b-a43f-2f27249a9b10.png">
</p>

このようなキューの仕組みを「先入れ先出し」という → 　 FIFO（**F**irst **I**n, **F**irst **O**ut）

<br>

#### イベントループ

イベントループは、コールスタックが空になっているかどうかを監視し、空きがあればタスクキューの先頭に並んでいるコールバック関数（非同期処理）を取り出して実行させるもの。

<p align="center">
  <img width="700px" alt="EventLoop" src="https://user-images.githubusercontent.com/39920490/231026849-1d1f379d-6553-4546-bf44-9881440ac95e.png">
</p>

```js
const btn = document.querySelector("button");
btn.addEventListener("click", function tasks() {
  console.log("task2 done");
});

function a() {
  setTimeout(function task1() {
    console.log("task1 done");
  }, 4000);

  const startTime = new Date();
  while (new Date() - startTime < 2000);
  console.log("fn a done");
}
```

<br>

#### コールバック関数と非同期処理

ブラウザの JavaScript 実行環境では、Web APIs と呼ばれる JavaScript からブラウザを操作するための機能が提供されている（`setTimeout`関数やマウス操作イベントなど）

特に Web APIs の機能の中でも非同期処理を行うものを利用する場合は、行わせたい非同期処理の内容をコールバック関数として記述し、該当の API メソッドを呼び出してコールバック関数を渡し、API に登録する使い方をする。

```js
function a() {
  // コールスタックが空になるまでは実行が待機される
  setTimeout(function task1() {
    console.log("task1 done");
  });

  console.log("fn a done");
}

function b() {
  console.log("fn b done");
}

a();
b();
// fn a done
// fn b done
// task1 done
```

上記のコードから関数 b を関数 task1 の後に実行されるよう書き換える。

```js
function a(b) {
  // コールスタックが空になるまでは実行が待機される
  setTimeout(function task() {
    console.log("task1 done");
    b();
  });

  console.log("fn a done");
}

function b() {
  console.log("fn b done");
}

a(b);
// fn a done
// task1 done
// fn b done
```

JavaScript における非同期処理は、次のような特徴を持つ。

- 非同期処理の本体は**コールバック関数として記述**される。
- 非同期処理を記述するときは、`setTimeout`関数や`addEventListener`メソッドのように**API コールバック関数を登録する関数**と、実際に<strong>非同期で実行させたい処理（コールバック関数）</strong>の 2 つをセットで記述する。
- 非同期処理は、**タスクキューに追加された順番で実行**される。
- 非同期処理は、タスクキューに追加され、イベントループによってコールスタックが空の時に取り出されて実行される。

<br>

### 非同期処理のチェーン

複数の非同期処理を、コールバック関数を使って連続的に処理する方法。

```js
function sleep(callback, val) {
  setTimeout(function () {
    console.log(val++);
    callback(val);
  }, 1000);
}

// 入れ子によって非同期処理を実行する
sleep(function (val) {
  sleep(function (val) {
    sleep(function (val) {
      sleep(function (val) {
        sleep(function (val) {
          console.log("callback done");
        }, val);
      }, val);
    }, val);
  }, val);
}, 0);
// 0 1 2 3 4 5 callback done
```

このように複数の非同期処理を連続して実行させる場合、コールバック関数の中で非同期処理の実行を繰り返すため、入れ子状態になりコードの可読性が悪くなる。

<br>

### Promise

非同期処理を**より簡単**に、**可読性が上がる**よう書けるようにしたオブジェクトで、ES6 から導入された。

```js
// Promise 構文（処理が成功した場合）
new Promise(function (resolve, reject) {
  resolve("hello");
})
  .then(function (data) {
    console.log(data); // hello
    // 次の非同期処理に引数を渡す
    return data;
  })
  .then(function (data) {
    console.log(data); // hello
  })
  .catch()
  .finally(function () {
    console.log("終了処理");
  });
```

```js
// Promise構文（エラーがあった場合
new Promise(function(resolve, reject) {
    reject('bye');
})
  .then({
      console.log('hello'); // hello
      // resolve処理中にcatchに処理を移行させたい場合
      throw new Error();
  }).catch(function(data) {
      console.log(data); // bye
  }).finally(function() {
      console.log('終了処理');
  });
```

複数の非同期処理を連続して実行させたい場合でも、ドットで繋いでいくことで入れ子構造にならずにコードの可読性を保ったままチェーンすることができる。

<br>

### Promise チェーン

Promise を使って非同期処理を順次実行すること。

非同期処理を繋げるためには、`then`メソッドの中で Promise のインスタンスを戻り値としてセットする必要がある。

`return`が抜けていると次のコールバック関数が処理の結果を待たずに実行されてしまう。<br>
=> 非同期処理チェーンする場合は、必ず**コールバックの戻り値に Promise のインスタンスをセット**する。

```js
function sleep(val) {
  // Promiseインスタンスを返す
  return new Promise(function (resolve) {
    setTimeout(function () {
      console.log(val++);
      resolve(val);
    }, 1000);
  });
}

sleep(0)
  .then(function (val) {
    return sleep(val);
  })
  .then(function (val) {
    // コールバック関数の戻り値にPromiseインスタンスをセットしないと、結果を待たずして次の処理に移行してしまう
    sleep(val);
    return val;
  })
  .then(function (val) {
    return sleep(val);
  });
```

<br>

### Promise と並列処理

- [Promise.all](#promiseall)
- [Promise.race](#promiserace)
- [Promise.allSettled](#promiseallsettled)

#### Promise.all

これまでは非同期処理を直列に実行していたが、並列して非同期処理を実行する場合、`Promise.all`を使って実現できる。

`Promise.all()`に**反復可能オブジェクト**をセットし、その中身に**Promise のインスタンス**を格納する。

`Promise.all`に格納された非同期処理がすべて完了するまで次の`then`メソッドの実行を待つようになる。

```js
function sleep(val) {
  // Promiseインスタンスを返す
  return new Promise(function (resolve) {
    setTimeout(function () {
      console.log(val++);
      resolve(val);
    }, 1000);
  });
}

Promise.all([sleep(2), sleep(3), sleep(4)]).then(function (data) {
  // それぞれの非同期処理の実行でresolveに渡した値が配列になって返ってくる
  console.log(data);
});
```

Promise チェーンの中で`Promise.all`を使いたい場合は、戻り値に記述する。

```js
sleep(0)
  .then(function (val) {
    return Promise.all([sleep(2), sleep(3), sleep(4)]);
  })
  .then(function (val) {
    console.log(val);
    return sleep(val);
  })
  .then(function (val) {
    return sleep(val);
  });
```

<br>

#### Promise.race

反復可能オブジェクトに格納した Promise インスタンスのうち、**どれか一つが完了したタイミング**で次の`then`へ処理が移行する。（`Promise.all`はすべての処理が完了しないと次の処理へは進めない）

```js
Promise.race([sleep(2), sleep(3), sleep(4)].then(function(data) {
    console.log(data);
});
```

<br>

#### Promise.allSettled

`Promise.all`とは違って、`Promise.allSettled`は完了した非同期処理が成功したか失敗したかに関わらず、すべての処理が終わって完了になる。

出力結果からは非同期処理が成功したか失敗したかがわからない。

また、`Promise.all`は`reject`が呼び出されたときに`catch`に処理が移るが、`Promise.allSettled`は`then`しか呼ばれない。

```js
Promise.all([sleep(2), sleep(3), sleep(4)])
  .then(function (data) {
    console.log(data);
  })
  .catch(function (e) {
    console.error(e);
  });

Promise.allSettled([sleep(3), sleep(4), sleep(5)]).then(function (data) {
  console.log(data);
});
```

<br>

### Macrotasks と Microtasks Part.1

- [マクロタスク](#マクロタスク)
- [マイクロタスク](#マイクロタスク)

#### マクロタスク

<br>

- [08 反復処理](../07_Loops_Iteration/08.md)
- [10 モジュラー JavaScript](../09_Modules/10.md)
- [Top へ戻る](../README.md)
